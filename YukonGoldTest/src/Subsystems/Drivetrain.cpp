// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "ctrlib/CANTalon.h"


#include "Drivetrain.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../Commands/drivewithjoysticks.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Drivetrain::Drivetrain() : Subsystem("Drivetrain") {
    InitHardware();

}

Drivetrain::~Drivetrain() {
}

void Drivetrain::InitHardware() {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	    frontleft = RobotMap::drivetrainfrontleft;
	    frontright = RobotMap::drivetrainfrontright;
	    robotDrive21 = RobotMap::drivetrainRobotDrive21;
	    rearleft = RobotMap::drivetrainrearleft;
	    rearright = RobotMap::drivetrainrearright;
	    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	    //Encoders
	    frontleft->SelectProfileSlot(0);
		frontright->SelectProfileSlot(0);

		frontleft->SetPID(0.1,0.0,0.0,0.0);
		frontright->SetPID(0.1,0.0,0.0,0.0);

		frontleft->SetEncPosition(0);
		frontright->SetEncPosition(0);

		//frontleft->SetSensorDirection(true);
		//frontright->SetSensorDirection(false);
}

void Drivetrain::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new drivewithjoysticks());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void Drivetrain::TankDrive(std::shared_ptr<Joystick>xbox){
	if(xbox->GetRawButton(6)==1){
		robotDrive21->TankDrive(0.4*xbox->GetRawAxis(5), 0.4*xbox->GetRawAxis(1));
	}
	else{
		robotDrive21->TankDrive(-xbox->GetRawAxis(1), -xbox->GetRawAxis(5));
	}
}

void Drivetrain::TankDrive(double left, double right){
	robotDrive21->TankDrive(left, right);
}

void Drivetrain::driveauto(){

	std::string _sb;
	int _loops = 0;
	double targetPositionRotations = 50.0;

	int leftencposition = frontleft->GetPulseWidthPosition();
	int rightencposition = frontright->GetPulseWidthPosition();

	frontleft->SetEncPosition(leftencposition);
	frontright->SetEncPosition(rightencposition);

	frontleft->SetFeedbackDevice(CANTalon::CtreMagEncoder_Relative);
	frontright->SetFeedbackDevice(CANTalon::CtreMagEncoder_Relative);

	frontleft->SetSensorDirection(false);
	frontright->SetSensorDirection(false);

	frontleft->ConfigNominalOutputVoltage(+0.,-0.);
	frontright->ConfigNominalOutputVoltage(+0., -0.);

	frontleft->ConfigPeakOutputVoltage(+12.0,-12.0);
	frontright->ConfigPeakOutputVoltage(+12.0,-12.0);

	frontleft->SetAllowableClosedLoopErr(0); // always servo
	frontright->SetAllowableClosedLoopErr(0); // always servo

	// set closed loop gains in slot0
	frontleft->SelectProfileSlot(0);
	frontright->SelectProfileSlot(0);
	frontleft->SetPID(0.1,0.0,0.0,0.0);
	frontright->SetPID(0.1,0.0,0.0,0.0);


	leftmotorOutput = frontleft->GetOutputVoltage() / frontleft->GetBusVoltage();
	rightmotorOutput = frontright->GetOutputVoltage() / frontright->GetBusVoltage();

	//prepare stuff to print
	_sb.append("\tout:");
	_sb.append(std::to_string(leftmotorOutput));
	_sb.append(std::to_string(rightmotorOutput));
	_sb.append("\tpos:");
	_sb.append(std::to_string(frontleft->GetPosition()));
	_sb.append(std::to_string(frontright->GetPosition()));



	frontleft->SetControlMode(CANTalon::kPosition);
	frontright->SetControlMode(CANTalon::kPosition);

	frontleft->Set(targetPositionRotations);
	frontright->Set(targetPositionRotations);



	//print information while in closed loop mode
	if (frontleft->GetControlMode() && frontright->GetControlMode() == CANSpeedController::kPosition) {
		// append more signals to print when in speed mode
		_sb.append("\terrNative:");
		_sb.append(std::to_string(frontleft->GetClosedLoopError()));
		_sb.append(std::to_string(frontright->GetClosedLoopError()));
		_sb.append("\ttrg:");
		_sb.append(std::to_string(targetPositionRotations));
	}

	//print every ten loops
	if (++_loops >= 10) {
		_loops = 0;
		printf("%s\n",_sb.c_str());
	}

	_sb.clear();


}

void Drivetrain::drivestop(){
	robotDrive21->TankDrive(0.0,0.0);
}

/*void Drivetrain::getleftdistance(){
	leftdistance = frontleft->GetEncPosition();
}

void Drivetrain::getrightdistance(){
	rightdistance = frontright->GetEncPosition();
}

void Drivetrain::resetencoders(){
	frontleft->SetEncPosition(0.0);
	frontright->SetEncPosition(0.0);

}

void Drivetrain::getaveragedistance(){
	double averagedistance = (frontleft->GetEncPosition() + frontright->GetEncPosition())/(2.0);
} */

void Drivetrain::Encoder(double left, double right, double leftspeed,
double rightspeed){
	frontleft->ConfigMaxOutputVoltage(leftspeed);
	frontright->ConfigMaxOutputVoltage(rightspeed);
	frontleft->SetControlMode(CANSpeedController::kPosition);
	frontleft->Set(left);
	frontright->SetControlMode(CANSpeedController::kPosition);
	frontright->Set(right);
	frontright->SetClosedLoopOutputDirection(true);
	l_pos = left;
	r_pos = right;

	SmartDashboard::PutNumber("LF POS", frontleft->GetEncPosition());
	SmartDashboard::PutNumber("RF POS", frontright->GetEncPosition());
}

bool Drivetrain::isMove() {
if ((frontleft->GetEncPosition() < (l_pos + .1) && frontleft->GetEncPosition() > (l_pos - .1))
&& frontright->GetEncPosition() < (r_pos + .1)
&& frontright->GetEncPosition() > (r_pos - .1)) {
return true;
} else {
return false;
}
}

void Drivetrain::EncoderDone() {
	frontleft->ConfigMaxOutputVoltage(12);
	frontleft->ConfigMaxOutputVoltage(12);
	frontleft->SetControlMode(CANSpeedController::kPercentVbus);
	frontleft->Set(0);
	frontright->SetControlMode(CANSpeedController::kPercentVbus);
	frontright->Set(0);
	l_pos = 0;
	r_pos = 0;
}

void Drivetrain::EncoderReset() {
	frontleft->SetEncPosition(0);
	frontright->SetEncPosition(0);
}

/*void Drivetrain::EncoderReport(std::string LorR) {
//	"LEFT" OR "RIGHT"
	if (LorR == "LEFT") {
		return frontleft->GetPosition();
	}
	if (LorR == "RIGHT") {
		return frontright->GetPosition();
	}
}

void Drivetrain::EncoderSpeed(std::string LorR) {
	//	"LEFT" OR "RIGHT"
	if (LorR == "LEFT") {
		return frontleft->GetSpeed();
	}
	if (LorR == "RIGHT") {
		return frontright->GetSpeed();
	}
}
*/
